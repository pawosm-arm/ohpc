From f82ad7797b1584685c0d841878c67508a802ecfa Mon Sep 17 00:00:00 2001
From: Jonathan Peyton <jonathan.l.peyton@intel.com>
Date: Fri, 7 Oct 2016 18:01:35 +0000
Subject: [PATCH 36/55] Enable omp_get_schedule() to return static steal type.

As the code is now, calling omp_get_schedule() when OMP_SCHEDULE=static_steal
will cause an assert.


git-svn-id: https://llvm.org/svn/llvm-project/openmp/trunk@283576 91177308-0d34-0410-b5e6-96231b3b80d8
---
 runtime/src/kmp.h                                  |  6 +-
 runtime/src/kmp_runtime.c                          |  4 +-
 .../worksharing/for/omp_for_schedule_runtime.c     | 82 ++++++++++++++++++++++
 3 files changed, 88 insertions(+), 4 deletions(-)
 create mode 100644 runtime/test/worksharing/for/omp_for_schedule_runtime.c

diff --git a/runtime/src/kmp.h b/runtime/src/kmp.h
index 6175e1f..203dd8b 100644
--- a/runtime/src/kmp.h
+++ b/runtime/src/kmp.h
@@ -288,8 +288,10 @@ typedef enum kmp_sched {
     kmp_sched_upper_std         = 5,     // upper bound for standard schedules
     kmp_sched_lower_ext         = 100,   // lower bound of Intel extension schedules
     kmp_sched_trapezoidal       = 101,   // mapped to kmp_sch_trapezoidal              (39)
-//  kmp_sched_static_steal      = 102,   // mapped to kmp_sch_static_steal             (44)
-    kmp_sched_upper             = 102,
+#if KMP_STATIC_STEAL_ENABLED
+    kmp_sched_static_steal      = 102,   // mapped to kmp_sch_static_steal             (44)
+#endif
+    kmp_sched_upper,
     kmp_sched_default = kmp_sched_static // default scheduling
 } kmp_sched_t;
 #endif
diff --git a/runtime/src/kmp_runtime.c b/runtime/src/kmp_runtime.c
index 847f9be..0e9e2c8 100644
--- a/runtime/src/kmp_runtime.c
+++ b/runtime/src/kmp_runtime.c
@@ -2766,11 +2766,11 @@ __kmp_get_schedule( int gtid, kmp_sched_t * kind, int * chunk )
     case kmp_sch_trapezoidal:
         *kind = kmp_sched_trapezoidal;
         break;
-/*
+#if KMP_STATIC_STEAL_ENABLED
     case kmp_sch_static_steal:
         *kind = kmp_sched_static_steal;
         break;
-*/
+#endif
     default:
         KMP_FATAL( UnknownSchedulingType, th_type );
     }
diff --git a/runtime/test/worksharing/for/omp_for_schedule_runtime.c b/runtime/test/worksharing/for/omp_for_schedule_runtime.c
new file mode 100644
index 0000000..b957fc3
--- /dev/null
+++ b/runtime/test/worksharing/for/omp_for_schedule_runtime.c
@@ -0,0 +1,82 @@
+// RUN: %libomp-compile
+// RUN: env OMP_SCHEDULE=static %libomp-run 1 0
+// RUN: env OMP_SCHEDULE=static,10 %libomp-run 1 10
+// RUN: env OMP_SCHEDULE=dynamic %libomp-run 2 1
+// RUN: env OMP_SCHEDULE=dynamic,11 %libomp-run 2 11
+// RUN: env OMP_SCHEDULE=guided %libomp-run 3 1
+// RUN: env OMP_SCHEDULE=guided,12 %libomp-run 3 12
+// RUN: env OMP_SCHEDULE=auto %libomp-run 4 1
+// RUN: env OMP_SCHEDULE=trapezoidal %libomp-run 101 1
+// RUN: env OMP_SCHEDULE=trapezoidal,13 %libomp-run 101 13
+// RUN: env OMP_SCHEDULE=static_steal %libomp-run 102 1
+// RUN: env OMP_SCHEDULE=static_steal,14 %libomp-run 102 14
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include "omp_testsuite.h"
+
+int sum;
+char* correct_kind_string;
+omp_sched_t correct_kind;
+int correct_chunk_size;
+
+int test_omp_for_runtime()
+{
+  int sum;
+  int known_sum;
+  int chunk_size;
+  int error;
+  omp_sched_t kind;
+
+  sum = 0;
+  error = 0;
+  known_sum = (LOOPCOUNT * (LOOPCOUNT + 1)) / 2;
+  omp_get_schedule(&kind, &chunk_size);
+
+  printf("omp_get_schedule() returns: Schedule = %d, Chunk Size = %d\n",
+         kind, chunk_size);
+  if (kind != correct_kind) {
+    printf("kind(%d) != correct_kind(%d)\n", kind, correct_kind);
+    error = 1;
+  }
+  if (chunk_size != correct_chunk_size) {
+    printf("chunk_size(%d) != correct_chunk_size(%d)\n", chunk_size,
+           correct_chunk_size);
+    error = 1;
+  }
+
+  #pragma omp parallel
+  {
+    int i;
+    #pragma omp for schedule(runtime)
+    for (i = 1; i <= LOOPCOUNT; i++) {
+        #pragma omp critical
+        sum+=i;
+    }
+  }
+  if (known_sum != sum) {
+    printf("Known Sum = %d, Calculated Sum = %d\n", known_sum, sum);
+    error = 1;
+  }
+  return !error;
+}
+
+int main(int argc, char** argv)
+{
+  int i;
+  int num_failed=0;
+  if (argc != 3) {
+    fprintf(stderr, "usage: %s schedule_kind chunk_size\n", argv[0]);
+    fprintf(stderr, "  Run with envirable OMP_SCHEDULE=kind[,chunk_size]\n");
+    return 1;
+  }
+  correct_kind = atoi(argv[1]);
+  correct_chunk_size = atoi(argv[2]);
+
+  for (i = 0; i < REPETITIONS; i++) {
+    if (!test_omp_for_runtime()) {
+      num_failed++;
+    }
+  }
+  return num_failed;
+}
-- 
2.7.3

