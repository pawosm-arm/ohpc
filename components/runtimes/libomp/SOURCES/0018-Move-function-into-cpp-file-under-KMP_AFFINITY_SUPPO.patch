From 0f2e7825153b4559cc70aeb976a04ab5ec05f031 Mon Sep 17 00:00:00 2001
From: Jonathan Peyton <jonathan.l.peyton@intel.com>
Date: Fri, 2 Sep 2016 20:54:58 +0000
Subject: [PATCH 18/55] Move function into cpp file under
 KMP_AFFINITY_SUPPORTED guard.

When affinity isn't supported, __kmp_affinity_compact doesn't exist.  The
problem is that in kmp_affinity.h there is a function which uses it without the
proper KMP_AFFINITY_SUPPORTED guard around it.  The compiler was smart enough to
ignore it and the function __kmp_affinity_cmp_Address_child_num which relies on
it, but I think it is cleaner to have it under the proper guard.  Since the
function is only used in the kmp_affinity.cpp file and there aren't any plans to
have it elsewhere.  I have moved it there.


git-svn-id: https://llvm.org/svn/llvm-project/openmp/trunk@280542 91177308-0d34-0410-b5e6-96231b3b80d8
---
 runtime/src/kmp_affinity.cpp | 25 +++++++++++++++++++++++++
 runtime/src/kmp_affinity.h   | 28 ----------------------------
 2 files changed, 25 insertions(+), 28 deletions(-)

diff --git a/runtime/src/kmp_affinity.cpp b/runtime/src/kmp_affinity.cpp
index fe987d8..251ee0c 100644
--- a/runtime/src/kmp_affinity.cpp
+++ b/runtime/src/kmp_affinity.cpp
@@ -3611,6 +3611,31 @@ static int     __kmp_aff_depth = 0;
     __kmp_apply_thread_places(NULL, 0);               \
     return;
 
+static int
+__kmp_affinity_cmp_Address_child_num(const void *a, const void *b)
+{
+    const Address *aa = (const Address *)&(((AddrUnsPair *)a)
+      ->first);
+    const Address *bb = (const Address *)&(((AddrUnsPair *)b)
+      ->first);
+    unsigned depth = aa->depth;
+    unsigned i;
+    KMP_DEBUG_ASSERT(depth == bb->depth);
+    KMP_DEBUG_ASSERT((unsigned)__kmp_affinity_compact <= depth);
+    KMP_DEBUG_ASSERT(__kmp_affinity_compact >= 0);
+    for (i = 0; i < (unsigned)__kmp_affinity_compact; i++) {
+        int j = depth - i - 1;
+        if (aa->childNums[j] < bb->childNums[j]) return -1;
+        if (aa->childNums[j] > bb->childNums[j]) return 1;
+    }
+    for (; i < depth; i++) {
+        int j = i - __kmp_affinity_compact;
+        if (aa->childNums[j] < bb->childNums[j]) return -1;
+        if (aa->childNums[j] > bb->childNums[j]) return 1;
+    }
+    return 0;
+}
+
 static void
 __kmp_aux_affinity_initialize(void)
 {
diff --git a/runtime/src/kmp_affinity.h b/runtime/src/kmp_affinity.h
index 8ed3415..0fa1f3d 100644
--- a/runtime/src/kmp_affinity.h
+++ b/runtime/src/kmp_affinity.h
@@ -15,8 +15,6 @@
 #ifndef KMP_AFFINITY_H
 #define KMP_AFFINITY_H
 
-extern int __kmp_affinity_compact; /* Affinity 'compact' value */
-
 class Address {
 public:
     static const unsigned maxDepth = 32;
@@ -112,32 +110,6 @@ __kmp_affinity_cmp_Address_labels(const void *a, const void *b)
 }
 
 
-static int
-__kmp_affinity_cmp_Address_child_num(const void *a, const void *b)
-{
-    const Address *aa = (const Address *)&(((AddrUnsPair *)a)
-      ->first);
-    const Address *bb = (const Address *)&(((AddrUnsPair *)b)
-      ->first);
-    unsigned depth = aa->depth;
-    unsigned i;
-    KMP_DEBUG_ASSERT(depth == bb->depth);
-    KMP_DEBUG_ASSERT((unsigned)__kmp_affinity_compact <= depth);
-    KMP_DEBUG_ASSERT(__kmp_affinity_compact >= 0);
-    for (i = 0; i < (unsigned)__kmp_affinity_compact; i++) {
-        int j = depth - i - 1;
-        if (aa->childNums[j] < bb->childNums[j]) return -1;
-        if (aa->childNums[j] > bb->childNums[j]) return 1;
-    }
-    for (; i < depth; i++) {
-        int j = i - __kmp_affinity_compact;
-        if (aa->childNums[j] < bb->childNums[j]) return -1;
-        if (aa->childNums[j] > bb->childNums[j]) return 1;
-    }
-    return 0;
-}
-
-
 /** A structure for holding machine-specific hierarchy info to be computed once at init.
     This structure represents a mapping of threads to the actual machine hierarchy, or to
     our best guess at what the hierarchy might be, for the purpose of performing an
-- 
2.7.3

